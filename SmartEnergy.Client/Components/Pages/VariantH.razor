@page "/varianth"
@attribute [StreamRendering]
@inject IMeasurementRepository measurementRepository;
@rendermode InteractiveServer

<PageTitle>Variant H</PageTitle>

<h1>Variant H</h1>

@if (measurements == null)
{
    <p><em>Data wordt geladen...</em></p>
}
else
{
    <div>
        <div>
            <label>
                Start Datum
                <input type="date" @bind="startDate" @bind:after="ValidateDates" />
            </label>
            <label>
                Eind Datum
                <input type="date" @bind="endDate" @bind:after="ValidateDates" />
            </label>
            @if (!string.IsNullOrEmpty(dateError))
            {
                <p style="color:red">@dateError</p>
            }
        </div>
        <div>
            <table class="table">
                <thead>
                    <tr>
                        <th>Timestamp (UTC)</th>
                        <th>Location ID</th>
                        <th>Sensor</th>
                        <th>Value</th>
                        <th>Unit</th>
                        <th>Price (energy only)</th>
                        <th>Temperature</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var measurement in measurements)
                    {
                        <tr>
                            <td>@measurement.Timestamp</td>
                            <td>@measurement.LocationId</td>
                            <td>@measurement.Sensor</td>
                            <td>@measurement.Value</td>
                            <td>@measurement.Unit</td>
                            <td>@measurement.EnergyPrice</td>
                            <td>@measurement.Temperature</td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>
}

@code {
    private List<Measurement>? measurements;
    private List<DailyEnergyConsumption> dailyEnergyConsumption = new();
    private DateOnly? endDate { get; set; } = DateOnly.FromDateTime(DateTime.Now);
    private DateOnly? startDate { get; set; } = DateOnly.FromDateTime(DateTime.Now.AddDays(-1));
    private string? dateError { get; set; }
    private int meterId = 1078608;
    private int numberOfDays = 1;
    private string aggregationWindow = "5m";

    private async Task ValidateDates()
    {
        if (startDate.HasValue && endDate.HasValue)
        {
            if (endDate.Value < startDate.Value)
            {
                endDate = startDate.Value.AddDays(1);
                dateError = "Eind datum mag niet voor start datum liggen";
            }
            else
            {
                dateError = null;
                await getMeasurements();
                CalculateDailyEnergyConsumption();
            }
        }
    }

    private void CalculateDailyEnergyConsumption()
    {
    }

    private async Task getMeasurements()
    {
        measurements = await this.measurementRepository.GetEnergyConsumed(
        meterId,
        numberOfDays,
        aggregationWindow,
        FormatDateOnly(startDate),
        FormatDateOnly(endDate)
        );
    }

    protected override async Task OnInitializedAsync()
    {
        await getMeasurements();

        if (measurements != null)
        {
            CalculateDailyEnergyConsumption();
        }
    }


    private string FormatDateOnly(DateOnly? date)
    {
        return date.HasValue
        ? date.Value.ToString("yyyy-MM-dd")
        : "";
    }

    private class DailyEnergyConsumption
    {
        public DateOnly Date { get; set; }
        public double TotalEnergy { get; set; }
        public double CheapEnergy { get; set; }
        public double ExpensiveEnergy { get; set; }
    }
}
